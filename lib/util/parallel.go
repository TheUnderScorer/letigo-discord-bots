package util

import "sync"

// ParallelWithValue runs the provided function `fn` in parallel across the input `data` with a concurrency limit of `limit`.
// It returns a slice of results generated by applying `fn` on each element of the `data`.
func ParallelWithValue[Payload any, Result any](data []Payload, fn func(payload Payload) *Result, limit int32) []Result {
	var wg sync.WaitGroup
	wg.Add(len(data))

	var mutex sync.Mutex
	var result []Result

	limitChan := make(chan bool, limit)

	for _, dataItem := range data {
		go func() {
			limitChan <- true
			defer func() {
				wg.Done()
				<-limitChan
			}()

			dataItemResult := fn(dataItem)
			if dataItemResult != nil {
				mutex.Lock()
				result = append(result, *dataItemResult)
				mutex.Unlock()
			}
		}()
	}

	wg.Wait()

	return result
}
